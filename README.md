# Завдання 1
# Порівняння алгоритмів видачі решти: Greedy vs DP

У цьому репозиторії наведено дві реалізації:

- **`find_coins_greedy(sum_)`** — жадібний алгоритм, який на кожному кроці бере найбільший можливий номінал монети.
- **`find_min_coins(sum_)`** — алгоритм динамічного програмування, який гарантує **мінімальну** кількість монет.

## Приклади
Для суми `113`:
- Greedy → `{50: 2, 10: 1, 2: 1, 1: 1}`
- DP     → `{1: 1, 2: 1, 10: 1, 50: 2}` (той самий оптимум у канонічній системі)

## Складність
- **Greedy**: час `O(n)` (n — кількість номіналів), пам’ять `O(1)`.
- **DP**: час `O(S·n)`, пам’ять `O(S)` (S — цільова сума). Оптимальність гарантована.

## Практична продуктивність (вимірювання цього запуску)
| Сума | Greedy (с) | DP (с) |
|---:|---:|---:|
| 113 | 0.000006 | 0.000100 |
| 10000 | 0.000003 | 0.009736 |
| 100000 | 0.000011 | 0.144386 |

### Висновки 

1. Greedy стабільно дуже швидкий на будь-яких сумах, адже проходить фіксований список номіналів один раз: 
час ≈ O(n), де n — кількість номіналів (для [50,25,10,5,2,1] це просто 6 перевірок). Час не росте з сумою S.
2. DP лінійно росте зі збільшенням `S` (DP заповнює таблицю для всіх проміжних сум 
від 1 до S: час ≈ O(S·n) та пам’ять O(S). Чим більша сума, тим повільніше й пам’яттєємніше),
але гарантує мінімальну кількість монет для **будь-якого** набору номіналів. 
3. Для канонічних валютних систем (як тут) Greedy є оптимальним і кращим вибором у продакшені за швидкістю/пам’яттю.
4. Якщо набір номіналів може бути неканонічним, доцільне використання DP для правильності результату.

## Запуск
```bash
python task01.py
```
