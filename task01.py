from time import perf_counter  # імпорт годинника високої роздільності для бенчмарків

# Набір доступних номіналів монет у касовій системі (канонічна система для якої greedy оптимальний).  # опис константи
COINS = [50, 25, 10, 5, 2, 1]  # список номіналів у спадаючому порядку для зручності greedy

def find_coins_greedy(sum_):  # оголошення функції жадібного алгоритму, приймає суму для видачі
    """Повертає словник {номінал: кількість} за жадібною стратегією."""  # докстрінг з описом призначення
    if not isinstance(sum_, int) or sum_ < 0:  # перевірка коректності вхідних даних: ціле невід’ємне число
        raise ValueError("sum_ має бути невід'ємним цілим числом")  # виняток із зрозумілим повідомленням
    result = {}  # підсумковий словник для збереження кількості монет кожного номіналу
    remaining = sum_  # змінна поточного залишку, який треба покрити монетами
    for coin in COINS:  # перебираємо номінали від найбільшого до найменшого
        count = remaining // coin  # обчислюємо, скільки монет цього номіналу поміщається в залишок
        if count > 0:  # якщо хоча б одна монета підходить
            result[coin] = count  # записуємо кількість монет цього номіналу в результат
            remaining -= coin * count  # зменшуємо залишок на вартість використаних монет
        if remaining == 0:  # якщо залишок дорівнює нулю
            break  # можна припинити цикл — суму зібрано повністю
    return result  # повертаємо словник з підібраними монетами

def find_min_coins(sum_):  # оголошення функції динамічного програмування, що мінімізує кількість монет
    """Повертає оптимальний (за мінімальною кількістю монет) набір як словник {номінал: кількість}."""  # докстрінг
    if not isinstance(sum_, int) or sum_ < 0:  # перевірка коректності вхідних даних
        raise ValueError("sum_ має бути невід'ємним цілим числом")  # у разі помилки піднімаємо виняток
    if sum_ == 0:  # граничний випадок: нульова сума
        return {}  # немає монет у відповіді
    min_coins_required = [0] + [float('inf')] * sum_  # масив мінімальної кількості монет для кожної суми 0..sum_
    last_coin_used = [0] * (sum_ + 1)  # масив «яку монету останньою брали» для відновлення рішення
    for s in range(1, sum_ + 1):  # для кожної проміжної суми від 1 до sum_
        for coin in COINS:  # намагаємось покласти кожен номінал
            if s >= coin:  # якщо монету можна покласти (не перевищує поточну суму)
                prev = s - coin  # індекс попередньої суми після взяття цієї монети
                if min_coins_required[prev] + 1 < min_coins_required[s]:  # якщо беремо монету — покращуємо відповідь
                    min_coins_required[s] = min_coins_required[prev] + 1  # оновлюємо мінімум кількості монет
                    last_coin_used[s] = coin  # запам’ятовуємо, яку монету взяли останньою для цієї суми
    if min_coins_required[sum_] == float('inf'):  # якщо сума недосяжна (теоретично з нашими монетами не станеться)
        raise ValueError("Неможливо скласти задану суму з наявних номіналів")  # повідомляємо про недосяжність
    result = {}  # словник для зворотного відновлення оптимального набору монет
    current = sum_  # починаємо відновлення з цільової суми
    while current > 0:  # поки не зійдемо до нуля
        coin = last_coin_used[current]  # беремо монету, яку використали останньою для цієї проміжної суми
        result[coin] = result.get(coin, 0) + 1  # збільшуємо лічильник відповідного номіналу
        current -= coin  # зменшуємо поточну суму на номінал використаної монети
    return result  # повертаємо словник з оптимальною кількістю монет

def _benchmark_once(sum_):  # допоміжна функція для одноразового вимірювання часу виконання для обох методів
    """Повертає кортеж (t_greedy, t_dp) у секундах для заданої суми."""  # докстрінг з описом
    # вимірюємо greedy
    t0 = perf_counter()  # фіксуємо стартовий час
    _ = find_coins_greedy(sum_)  # викликаємо жадібну функцію
    t1 = perf_counter()  # фіксуємо час після виконання
    # вимірюємо DP
    t2 = perf_counter()  # старт для DP
    _ = find_min_coins(sum_)  # викликаємо DP-функцію
    t3 = perf_counter()  # час після виконання DP
    return (t1 - t0, t3 - t2)  # повертаємо різниці часу як витрати на кожен метод

if __name__ == "__main__":  # стандартна точка входу при запуску файлу як скрипту
    test_sum = 113  # прикладова сума з умови
    print("Greedy для", test_sum, "->", find_coins_greedy(test_sum))  # демонстраційний вивід результату greedy
    print("DP     для", test_sum, "->", dict(sorted(find_min_coins(test_sum).items())))  # вивід результату DP (відсортовано)
    # бенчмарк на кількох сумах
    sums = [113, 10_000, 100_000]  # набір сум для порівняння продуктивності
    print("\nБенчмарк (секунди):")  # заголовок таблиці
    print("сума\tgreedy\tDP")  # шапка з колонками
    for s in sums:  # перебір тестових сум
        tg, td = _benchmark_once(s)  # вимірюємо час для кожної суми
        print(f"{s}\t{tg:.6f}\t{td:.6f}")  # друкуємо результат у зручному табличному форматі
